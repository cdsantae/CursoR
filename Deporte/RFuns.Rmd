---
title: "Funciones y Paquetes en R"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Estructura de decisión

Normalmente, los operadores lógicos y relacionales se utilizan con sentencias de programación condicional *si* y *si no*. La sentencia `if` se puede utilizar sola o con la sentencia `else`. La forma de la sentencia `if` es:

```{r eval=FALSE}
# Ejemplo 1
if( <condición verdadera> )
  entonces haga esto

# Ejemplo 2
if( <condición verdadera> ){
  entonces haga esto
}else{#si no
  entonces haga esto otro
} 
  
```

La condición entre paréntesis usualmente usará un operador relacional para determinar si la condición es verdadera. Cuando la instrucción `if` se usa sola y la condición entre paréntesis no es verdadera, entonces no sucede nada. Por ejemplo:

```{r}
x<-6; y<-2

# Si x es menor o igual que y entonces asigne z
if(x<=y) z<-x+y

# La condición no es verdadera, entonces no sucede nada
# z

# Si la relación es contraria, entonces la condición es verdadera
if(x>=y) z <- x+y
z

# También se puede asignar antes del if
z <- if(x>=y) x+y
z
```

Para que algo suceda si la condición entre paréntesis no es verdadera, use `if` junto con `else` para especificar una alternativa. Tenga en cuenta que no hay una condición entre paréntesis después de la instrucción `else`. En este caso, el código que sigue a continuación se ejecutará siempre que la condición `if` no sea verdadera.

```{r}
if(x<y){
  z <- x+y
}else{
  z <- x*y
}
z

# El resultado se puede llevar a una variable
z <- if(x<y) {x+y} else {x*y}
z
```

En la condición se puede utilizar varios operadores lógicos.

```{r}
a <- 3; b <- 5; c <- 1

if(a<b & b>c){ 5 }else{ 4 }
if(a<b & b<c){ 5 }else{ 4 }
if(a>b | b<c){ 5 }else{ 4 }
if(a>b | b>c & a!=c){ 5 }else{ 4 }
if((a>b | b>c) & (a!=c & b<a)){ 5 }else{ 4 }
```

Si se pretende evaluar varias condiciones para obtener más de dos valores de respuestas, es posible anidar los condicionales.

```{r}
if(a<b & b>c){
  if(c>a){
    8
  }else{
    5
  }
}

if(a<b & b<c){
  if(c<a){
    8
  }else{
    5
  }
}else{
  if(a==c){
    7
  }else{
    4
  }
}
```

En `R` existe una función útil para reemplazar valores dependiendo de un condicional.

```{r, eval=FALSE}
?ifelse
```

```{r}
(x <- 4:12)

ifelse(x!=7, 1, 0)
ifelse(x!=7, 1, x)
ifelse(x!=7, x, NA)

# Muestre los impares
# na.omit(ifelse(x%%2, x, NA))
ifelse(x%%2, x, NA)

# Muestre los pares
# na.omit(ifelse(x%%2, NA, x))
ifelse(x%%2, NA, x)
```

## Estructuras de repetición

El control por repetición, o bucle, le permite repetir el código de manera eficiente sin tener que escribir el mismo código una y otra vez. En `R` dos expresiones comunes de bucle son `for` y `while`.

Los bucles `for` se utilizan para recorrer un proceso un número específico de veces. Se utiliza una variable de contador (generalmente designada por una letra minúscula `i`) para contar cuántas veces se ejecuta el bucle.

```{r, eval=FALSE}
for(<variable> in <comienzo>:<final>){
  ejecute la tarea
}
```

Dentro de la sentencia del `for` se tiene que especificar una secuencia de recorrido, ya sea con el operador `:` o ingresando un vector definido.

```{r}
for(i in 1:10){
  print(i)
}

# Secuencia basada en las posiciones del vector
x <- c("a","b","c","d")
for(i in 1:4){
  print(x[i])
}

# Secuencia basada en el tamaño del vector
for(i in seq_along(x)){
  print(x[i])
}

# Secuencia basada en los elentos del vector
for(letras in x){
  print(letras)
}

# Se puede hacer en una sola línea
for(i in 1:4) print(x[i])
```

Los bucles `for` pueden ser anidados uno dentro de otro.

```{r}
(x <- matrix(1:6, 2, 3))

for(i in 1:nrow(x)){
  for(j in 1:ncol(x)){
    print(x[i,j])
  }
}

# Se puede utilizar los ciclos para construir objetos
(x <- matrix(NA, 4, 4))

for(i in 1:ncol(x)){
    for(j in 1:nrow(x)){
      if(i%%2==0){
        x[j,i] <- 2*(i+j)
    }else{
        x[j,i] <- 2*(i+j)-1
    }
  }
}
x
```

El bucle `while` repite una condición mientras que la expresión entre paréntesis es verdadera y toma la forma

```{r,eval=FALSE}
while (<condición verdadera>) {
  ejecute la tarea
}
```

Los bucles `While` comienzan probando una condición. Si es verdad, entonces ejecutan el cuerpo del bucle. Una vez que se ejecuta el cuerpo del bucle, la condición se prueba de nuevo, y así sucesivamente, hasta que la condición es falsa, después de lo cual el bucle termina.

```{r}
count <- 0
while(count < 10){
  print(count)
  count <- count + 1
}
```

Los bucles `while` pueden dar lugar a bucles infinitos si no se escriben correctamente. ¡Usa esto con cuidado!
A veces habrá más de una condición en la prueba.

```{r}
z <- 5
set.seed(1) # Establecer semilla de números aleatorios

while(z >= 3 && z <= 10){
  moneda <- rbinom(1, 1, 0.5) # número aleatorio bernoulli p=1/2
  
  if(moneda == 1){  # caminata aleatoria
    z <- z + 1
  }else{
    z <- z - 1
  }
}
print(z)

# Para saber cuántas veces hace la caminata se usa un auxiliar
z <- 5
cuenta <- 1
set.seed(1)

while(z >= 3 && z <= 10){
  moneda <- rbinom(1, 1, 0.5)
  
  if(moneda == 1){
    z <- z + 1
  }else{
    z <- z - 1
  }
  cuenta <- cuenta+1
}
print(z)
print(cuenta)
```

El ciclo `repeat` inicia un bucle infinito desde el principio. Estos no se utilizan comúnmente en aplicaciones estadísticas o de análisis de datos, pero tienen sus usos. La única forma de salir de un ciclo de repetición es llamar a `break`.

```{r, eval=FALSE}
repeat{
  ejecute tareas
}
```

Un posible paradigma podría ser un algoritmo iterativo en el que esté buscando una solución y no quiera detenerse hasta que esté lo suficientemente cerca de la solución. En este tipo de situación, a menudo no se sabe de antemano cuántas iteraciones se necesitarán para "acercarse lo suficiente" a la solución.

```{r}
# Número de raíces cuadradas
x0 <- 1000
tol <- 1e-08
pasos <- 1

repeat{
  x1 <- sqrt(x0)
  if(abs(x1-x0) < tol){
    break
  }else{
    x0 <- x1
  }
  pasos <- pasos+1
}
x0
pasos
```

Los argumentos `next` y `break` son utilizados comúnmente cuando se quiere omitir pasos de un ciclo, o cuando se quiere parar el ciclo en un momento dado, respectivamente.

```{r}
x <- NULL
for(i in 1:50){
  if(i <= 20){ #omitir los primeros 20 pasos
    next
  }
  x <- c(x,i)
}
x

y <- NULL
for(j in 1:1000){
  if(j > 20){ #parar antes de 20 iteraciones
    break
  }
  y <- c(y,j)
}
y
```

## Secuencias

* `seq()` genera una secuencia regular de números
* `rep()` repite un objeto un numero definido de veces
* `seq_along()` genera una secuencia regular basado en el tamaño del objeto
* `seq_len()` genera una secuencia regular con un tamaño específico
* `sequence()` genera una secuencia concatenando los elementos
* `gl()` genera una secuencia de factores
* `:` genera una secuencia regular de números
* `expand.grid()` crea un marco con todas las posibles combinaciones de vectores o factores

```{r}
seq(from = 1, to = 10, by = 2)
seq(from = 5, to = 8, length.out = 10)
seq(20)
seq_along(1:20)
seq_len(20)

rep(4, 5)
rep(1:4, 3)
rep(c("Hola","Clase"),5)

sequence(4)
sequence(c(2,5))
sequence(1:10)

gl(n = 1,k = 6)
gl(5, 2, labels = c("Juliana","Carlos","Lina","Manuela","Adriana"))
gl(5, 4, labels = c("Juliana","Carlos","Lina","Manuela","Adriana"),ordered = T)
gl(3,2,18)
gl(3,4,24,labels = c("Chicles","Cigarrillos","Tinto"))
gl(3,1,24,labels = c("Chicles","Cigarrillos","Tinto"))

expand.grid(a=c(60,80), p=c(100, 300), sexo=c("Macho", "Hembra"))
expand.grid(edad=seq(18,30,by=3), nota=(seq_len(5)/2)+2,
            color=gl(3,1,labels = c("Rojo","Verde","Blanco")),
            profesion=c("Ingeniero","Arquitecto"))
```

## Funciones

Construir funciones es una las principales actividades para pasar de ser usuarios a programadores en el lenguaje `R`. Las funciones se utilizan a menudo para encapsular una secuencia de expresiones que deben ejecutarse varias veces, quizás en condiciones ligeramente diferentes. Las funciones también suelen escribirse cuando el código debe compartirse con otros o con el público.

La escritura de una función permite a un desarrollador crear una interfaz para el código, que se especifica explícitamente con un conjunto de parámetros. Esta interfaz proporciona una abstracción del código a los usuarios potenciales. Esta abstracción simplifica la vida de los usuarios porque les libera de tener que saber cada detalle de cómo funciona el código. Además, la creación de una interfaz permite al desarrollador comunicar al usuario los aspectos del código que son importantes o más relevantes.

```{r, eval=FALSE}
NombreFuncion <- function(<argumentos>){
  Cálculos con los argumentos de la función.
  Series de instrucciones en R.
  Desarrollo del cuerpo de la función.
}
```

### Elementos de una función.

Todas las funciones en `R` tienen las siguientes partes:

* **El Cuerpo:** Es el código propio de la función `body()`.
* **Parámetros Formales:** Lista de argumentos de la función `formals()`, `formalsArgs()` o `args()`.
* **Entorno:** Mapa donde se localizan las variables de la función `environment()`.

```{r, eval=FALSE}
FuncionEjemplo <- function(){
  # Esta función no hace nada, pero no es un error
}
FuncionEjemplo
```


```{r}
CuadradoNumero <- function(n){
  n*n #Halle el cuadrado del número
}
CuadradoNumero(8)
formals(CuadradoNumero)
body(CuadradoNumero)
environment(CuadradoNumero)

a <- 20
m <- CuadradoNumero(a)
m
```

### Entrega de resultados

La instrucción `return()` finaliza la función, y se recomienda usar al final de la función.

```{r}
promedio <- function(x){
  n <- length(x)
  suma <- sum(x)
  pro <- suma/n
  return(pro)
}

set.seed(2019)
(y <- sample(x = 10,size = 8))
promedio(y)

# Entrega incorrecta de resultados
funMala <- function(a,b){
  w <- a/b
  x <- a+b
  y <- a^b
  z <- b*a
}
r1 <- funMala(5,7)
r1

# Entrega correcta de resultados
funBuena <- function(a,b){
  w <- a/b
  x <- a+b
  y <- a^b
  z <- b*a
  return(c(w,x,y,z))
}
r2 <- funBuena(5,7)
r2
```

Si se quiere entregar resultados más complejos se recomienda devolverlo en forma de lista con la función `list()`.

```{r}
MiFuncion1 <- function(x,y){
  z <- sqrt((x-0)^2+(y-0)^2)
  coord <- expand.grid(punto=c(x,y),origen=c(0,0))
  list(z,coord)
}
MiFuncion1(14.2,-5.8)
MiFuncion1(14.2,-5.8)[[1]]
MiFuncion1(14.2,-5.8)[[2]]
MiFuncion1(14.2,-5.8)$coord

MiFuncion2 <- function(x,y){
  z <- sqrt((x-0)^2+(y-0)^2)
  coord <- expand.grid(punto=c(x,y),origen=c(0,0))
  list(distancia=z,coordenadas=coord)
}
MiFuncion2(14.2,-5.8)
MiFuncion2(14.2,-5.8)$distancia
MiFuncion2(14.2,-5.8)$coordenadas
```

### Tipos de argumentos

Las funciones pueden recibir cualquier clase de atómico y sus construciones particulares, ya sean vectores, matrices, listas o dataframes, siempre y cuando el cuerpo de la función y los cálculos con los argumentos lo permitan.

```{r}
x <- c(5, -8, 7, 10, 9)
y <- c(0.2, 7, 6.5, -9, 8)
MiFuncion2(x,y)

set.seed(2019)
(x <- matrix(sample(20,9),3,3))
(y <- matrix(runif(9,-5,5),3,3))
MiFuncion2(x,y)
```

### El argumento `...`

El argumento `...` indica un número variable de argumentos, que usualmente se pasan a otras funciones. `...` se usa para extender otra función y no se quiere copiar la lista completa de los argumentos de la función.

```{r}
mean

DesvMedicion <- function(x,...){
  m <- mean(x,...)
  d <- sd(x,...)
  res <- c(m-d,m,m+d)
  return(res)
}

set.seed(2019)
(a <- rnorm(10,mean = 5,sd = 2))
DesvMedicion(a)

b <- c(8,7.5,NA,5.4,9.2,8)
DesvMedicion(b)
DesvMedicion(b,na.rm=TRUE)

```

## Recomedaciones

* Realice los ejercicios de algoritmos. (Adquira un pensamiento algorítmico).
* Comente su código.
* RTFM!. (LEMM o LEPM)
* Piense antes de escribir. (Piense primero en el que y luego en el como).
* Diseñe en forma “top-down”, codifique en forma “bottom up”.
* Divida el problema en pequeñas funciones significativas.
* Evite escribir la misma rutina dos veces.
* Use nombres relevantes.
* Realice una prueba de escritorio o seguimiento. (función por función en forma “bottom up”)
* No se rinda, ¡¡quéjese!! (ayuda a listas, compañeros, etc).
* Evite iteracciones (R es vectorizado)

## Uso de librerías

Todas las funciones y conjuntos de datos de `R` están alojados en librerías o paquetes, solamente cuando los paquetes son cargados sus contenidos estarán disponibles.

Para ver cuáles paquetes están instalados en su computador, use este comando.

```{r,eval=FALSE}
library()
```

Si quiere cargar un paquete, por ejemplo `psych`, use este comando.

```{r, eval=FALSE}
library(psych)
require(psych)
```

Si aparece un error, significa que no tienes instalado o correctamente instalado el paquete que deseas usar. Para conectarse a internet e instalar o actualizar un paquete, usa estos comandos.

```{r, eval=FALSE}
# Instalar un paquete
install.packages("psych",dependencies = TRUE)

# Actualizar un paquete
update.packages("psych")
```

Para ver cuales paquetes están cargados actualmente, puedes ver en la pestaña **Packages** de RStudio o utilizar los siguientes comandos.

```{r,eval=FALSE}
search()
sessionInfo()
sessioninfo::package_info()
```

Para utilizar paquetes dentro de las funciones se recomienda cargarlos con el comando `require`, ya que permite que el código se ejecute así no exista el paquete; utilizar el comando `library` dentro de una función puede parar la ejecución sino existe el paquete.

En algunas ocasiones no es necesario cargar el paqute para utilizar una función determinada, con el operador `::` se puede acceder al paquete y extraer la función deseada.

```{r}
summary(mtcars) # Resumen estadístico básico
psych::describe(mtcars) # Resumen estadístico detallado
psych::describeBy(iris,iris$Species) # Resumen estadístico detallado por factor
```

Ponlo en práctica aquí:

<iframe width='100%' height='600' src='https://rdrr.io/snippets/embed/?code=%0A' frameborder='2'></iframe>

<hr>

## Análisis descriptivo con RCommander

En `RCommander` también se puede copiar código y generar resultados, no obstante, el software es una interfaz gráfica amigable para trabajar de forma más sencilla en `R`. En el siguiente video, se muestra un ejemplo de cómo utilizar el `RCommander` con un conjunto de datos.

- Descarga la [Base de datos](./R/BD_1.xlsx) para practicar.

<center><iframe width="648" height="405" src="https://www.youtube.com/embed/zqdgTM8eQkE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></center>

